## 十大基础排序算法的比较
### 1.冒泡排序
#### 思想：把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或者等于右侧相邻元素时，位置不变
#### 时间复杂度：O(n^2)
#### 空间复杂度：O(1)
#### 是否稳定：稳定

### 2.选择排序
#### 思想：先规定左边为最小每轮选择最小者,直接交换到数组最左边
#### 时间复杂度：O(n^2)
#### 空间复杂度：O(1)
#### 是否稳定：不稳定。 原始数组越无序，性能越好，

### 3.插入排序
#### 思想：维护一个有序区，把元素一个一个插入到有序区的适当位置，直到所有元素有序
#### 时间复杂度：O(n^2)
#### 空间复杂度：O(1)
#### 是否稳定：稳定。 原始数组越有序，性能越好

### 4.堆排序
#### 思想：将原始数组构建成一个最大堆或最小堆
#### 时间复杂度：O(nlogn)
#### 空间复杂度：O(1)
#### 是否稳定：不稳定 

### 5.归并排序
#### 思想：把数组拆成两两一组，有序合并，并递归，经典的分治思想
#### 时间复杂度：O(nlogn)
#### 空间复杂度：O(n)
#### 是否稳定：不稳定 需要额外的merge数组 
 
### 6.快速排序
#### 思想：快排也是分治思想的经典体现,即：选择一个基准元素，大于它的在一边，小于它的在另一边，并递归
#### 时间复杂度：平均O(nlogn) 最坏O(n^2)
#### 空间复杂度：O(1)
#### 是否稳定：不稳定 弊端会根据所选的基准pivot 影响性能

### 7.希尔排序
#### 思想：是插入排序的升级版，跳间隔比较大小，即（插入排序的间隔为1），希尔排序的间隔是可变的。对原数组进行一些预处理，使原数组大部分元素变得有序，
#### 时间复杂度：O(n^1.3)
#### 空间复杂度：O(1)
#### 是否稳定：不稳定 

### 8.计数排序
#### 思想：统计原始数组的值出现的次数生成计数数组,遍历计数数组，生成排序数组。基于元素下标来确定元素的位置，不依靠元素的比较和交换
#### 时间复杂度：O(n+m)
#### 空间复杂度：O(n+m)
#### 是否稳定：不稳定 弊端只能比较整数

### 9.桶排序
#### 思想：桶排序是为了弥补计数排序的无法适用于非整数的情况,也是分治思想的体现。 桶排序按值区间将原始数组分配到不同的值区间（桶），分完之后桶已经是有序的了，只有遍历这几个桶，分别排好每个桶的顺序就行了
#### 时间复杂度：桶数量为n时O(n)
#### 空间复杂度：桶数量为n时O(n)
#### 是否稳定：稳定 

### 10.基数排序
#### 思想：统计数组元素的最大长度，根据位数先排个位，再排十位，然后再排百位以此类推，只要排序算法是稳定的，最后整体就是有序的。
#### 时间复杂度：O(nlogn)
#### 空间复杂度：O(k(m+n))
#### 是否稳定：稳定 
